메모리
1. 메모리 구조
	프로그램을 수행하기 위해 운영체제로부터 메모리(RAM)공간을 할당 받는다.
	메모리의 구조는 4가지로 구분된다. Code, Data, Heap, Stack으로 나뉘며 위에서부터
	낮은 주소(low address)를 가지게 되고 아래로 갈수록 높은 주소(high address)를 가진다.

	코드(Code)영역
		프로그램의 코드가 저장되는 영역이며 소스코드가 들어가는 부분이다.
		함수, 제어문, 상수 등 실행파일을 구성하는 명령어가 저장된다.
		프로그램이 종료할때까지 메모리가 유지된다.

	데이터(Data)영역
		프로그램의 공용영역으로 불리며 전역변수, static변수, 문자열 상수가 저장되는 영역이다.
		프로그램 시작과 동시에(컴파일 시점) 할당되어 프로그램이 종료되기 전 까지 메모리가 있다.

	힙(Heap)영역 - " FIFO "
		프로그래머가 관리할 수 있는 공간이며, malloc 함수와 new연산자를 통해 동적 할당을 진행하고
		 free와 delete를 이용하여 할당된 메모리를 해제를 할 수 있다.
		프로그램이 실행될때(런타임) 크기를 지정되어지며 종료 후 지정된 메모리는 사라진다.

		C#의 경우 참조 형식이 추가되는 메모리 공간이며, 
		참조 형식의 변수는 스택영역과 힙영역을 동시에 이용하는데, 
		스택영역에는 데이터의 주소를, 힙영역에는 데이터의 값을 저장한다.
		C#에서는 가비지 컬렉터가 주기적으로 힙을 청소하여 사용자 대신 메모리 관리를 한다..

	스택(Stack)영역 - " LIFO "
		프로그램이 자동으로 사용하는 임시 메모리 영역이며, 
		함수 호출 시 생성되는 지역변수와 매개 변수가 저장되는 영역이고 
		스택의 크기는 컴파일 과정시 크기가 지정된다.
		스택영역의 할당의 경우 함수의 호출시 할당 되고 함수가 종료되면 사라진다.
		스택 영역에 저장되는 함수의 호출 정보를 스택 프레임(stack frame)이라고 한다.

2. Heap vs Stack
	힙(Heap)영역과 스택(Stack)영역은 같은 공간을 분활해서 사용하는데 
	힙은 낮은 주소(low address)를 사용하고 스택은 높은 주소(high address)를 사용한다.

	힙과 스텍공간에서 문제가 발생될때 가 있는데 서로의 영역을 침범하게 되면 "오버 플로우(over flow)"가 발생된다. 
	힙이 침범시 Heap over flow, 스택이 침범시 Stack over flow가 발생된다.

	둘다 비어있는데 꺼내려는 상태는(지웠는데 또 지우려는 상태) "언더 플로우(under flow)"가 발생된다.

	가비지 컬렉터(Garbage Collector)
		C, C++에서는 프로그래머가 직접 메모리의 할당화 해제를 관리해줘야 했지만, 
		C#에서는 자동적으로 힙 메모리를 관리해주는 가비지컬렉터라는 프로세스를 도입.
		상당히 편리한 기능이지만, 그렇다고 사용자가 메모리 관리에 전혀 신경 쓸 필요가 없다는 뜻은 아님.
		무분별하게 남용시 프로그램 성능 저하의 원인이 된다.

	1. 가비지(Garbage) 생성원인
		가비지(Garbage) - 더 이상 참조되지 않는 메모리를 의미한다.
	
		(1) '+' operrator로 문자열을 조합할때 (string의 불변성)

		(2) 메서드 안의 생성객체가(new) 메서드 종료시에는 더이상 사용되지 않는 가비지가 된다.
	  	 단, 구조체의 경우는 값타임이기에 스택(stack)메모리에 저장되어 상관없다.
	
		(3) Boxing인 경우 - Boxing이랑 값타입의 객체를 참조타입 객체로 포장하는 과정을 말한다.

		(4) List를 많이 사용하는 경우 - 잦은 데이터 복사와 가비지 생성을 동시에 유발하게 한다.

	2. 가비지 컬렉터 작동방식
		가비지 컬렉터(GC)는 효율적으로 작동하기 위해서 객체마다 세대를 매긴다.

	가비지 컬렉터 작동방식
		GC를 2번이상으로 견디면 2세대로 판별되고 세대가 높을수록 GC가 중요한 객체라고 판단하는 방식이다. 
		낮은 세대인 0세대부터 메모리 확보를 위해서 가비지 컬렉팅(Garbage Collectiong)이 시행되는데 
		부족할시 그 다음 세대 부분을 포함하여 가비지 컬렉팅을 시행한다. 
		이때 메모리 부족으로 2세대까지 포함하게 되는 경우 프로세스가 일시 정지상태가 되고 
		우선적으로 시행이되기에 프레임 드랍현상이 발생한다.

		그리고 GC는 객체의 크기에 따라서 분류를 하는데 85kb(85,000byte)보다 작은 경우 SOH(Small Of Heap), 
		크거나 같은경우 LOH(Large Of Heap)으로 구분한다. 
		SOH의 경우 0세대부터 시작하고 LOH의 경우 2세대부터 시작한다. 
		크기가 큰 객체는 중요객체로 인식한다.
		또한 SOH의 경우는 메모리 단편화를 없애기 위해서 위치가 조정되지만,
		LOH의 경우 옮기게되면 오버헤드의 크기가 크기 때문에 이동되지 않는다.

